{
#if 1

//:preserve
//IMPORTAND: this forward declaration is neccesary to make it work
/// @sa util::preserve< Field_T, Remaining_T...>
template <typename... List_T>
struct preserve;
/**
 @brief use RAII to "preserve" data and automatically restore it at the end of the scope
 @sa PRESERVING decltypes0 ... decltypes9

 preserve offers a powerfull jet easy to use and safe programming interface to ensure that prior content of a object
 which content will change in the scope - where the preserve object is used - will be restored when the scope is left
 no matter how it is left ( return, exception e.g. ).

 To preserve a single object a template pointer is required to remember the address of the object and a template object
 to copy the original value. When leaving the scope the destructor of preserve restores the original value. By use of
 C++11 variadic template argument techniques, any amount of multiple objects can be "preserved".

 Macro PRESERVING encapsulates the declaration of preserve for further simplification.

 @remark There are no methods to use. The constructors are encampsulated in PRESERVING and the destructors are called
         automatically. So there is nothing to further document here (as we limit doxygen documentaion to  a need to
         know - mainly "public" - area).
 */
template <typename Field_T,typename... Remaining_T>
struct preserve<Field_T,Remaining_T...> : preserve<Remaining_T...>
{
    Field_T safed, *ptr_orinal;
    // simple trasaction support (do not restore in destructor if '..commit()' is called
    // bool rolledback

    // provide modification visabillity ( take address of object at call )
    inline
    explicit preserve( Field_T* _fieldptr, Remaining_T*... _remaining)
    : preserve<Remaining_T*...>(_remaining...)
    , safed(*_fieldptr)
    , ptr_orinal(_fieldptr)
    // rollback(true)
    {
        //VARVAL(safed);
    }


//  NOTE: use of 1st constructor is recommended
//        this is the backwards compatible constructor
    inline
    explicit preserve( Field_T& _field, Remaining_T&... _remaining)
    : preserve<Remaining_T...>(_remaining...)
    , safed(_field)
    , ptr_orinal(&_field)
    // rollback(true)
    {
        //VARVAL(safed);
    }

    inline
    ~preserve()
    {
        // if (rolledback) {
        ( *ptr_orinal )= safed;
        //}

        //VARVAL(safed);
    }

  private:
    // prevent -Weffc++ , do not make a copy of instances of this class (because of pointer members), no need/purpose
    //const util::preserve<bool>& (const util::preserve<bool>&) const
    preserve(const preserve<bool>&)
    {
        Throw_Error_Break(std::runtime_error("util::preserve<...> objects should not be copied"));
    }

    //void commit(){  rolledback=fale; on_commit_event();}
};

/*last*/
/// @sa util::preserve< Field_T, Remaining_T...>
template <>
struct preserve<>
{
#if 0
    inline
    preserve<>(){}

    inline
    ~preserve(){}
#endif
};

//:NUMARGS
/**
 @brief determine number of arguments from a variadic macro
 @remark NUMARGS cannot substitute static numbering
 */
#define NUMARGS(...)  (sizeof((int[]){__VA_ARGS__})/sizeof(int))

//:decltypes0...9
/// decltypes0...9 are helper macros for PRESERVE @sa PRESERVE
#define decltypes0()
/// @overload
#define decltypes1(_1)                                decltype(_1)
#define decltypes2(_1,_2)                             decltype(_1), decltypes1(_2)
#define decltypes3(_1,_2,_3)                          decltype(_1), decltypes2(_2,_3)
#define decltypes4(_1,_2,_3,_4)                       decltype(_1), decltypes3(_2,_3,_4)
#define decltypes5(_1,_2,_3,_4,_5)                    decltype(_1), decltypes4(_2,_3,_4,_5)
#define decltypes6(_1,_2,_3,_4,_5,_6)                 decltype(_1), decltypes5(_2,_3,_4,_5,_6)
#define decltypes7(_1,_2,_3,_4,_5,_6,_7)              decltype(_1), decltypes6(_2,_3,_4,_5,_6,_7)
#define decltypes8(_1,_2,_3,_4,_5,_6,_7,_8)           decltype(_1), decltypes7(_2,_3,_4,_5,_6,_7,_8)
#define decltypes9(_1,_2,_3,_4,_5,_6,_7,_8,_9)        decltype(_1), decltypes8(_2,_3,_4,_5,_6,_7,_8,_9)

//:PRESERVING
/**
 @brief preserving content of N object entities

 @param [in] N number of objects to preserve
 @param [in] in_local_preserveObject name of the 'preserve' object in the preserving scope
 @param [in] ... variadic list of object intities whose content will be preserved

@b example:
\code
int a=10;
float e=-12.5;

if ( ... ) {
   PRESERVING( 2, till_scope_end  ,a,e);
   a=20;
   e=-33.33;
   foo( a, e);
}
 // e== -12.5
 // e== 10
\endcode

@remark It would be nice if N not needed to be specified but could be retrieved from the number of
        enlisted object entities. NUMARGS seems to come close but can't be combined with decltypes0...9 .
        Who knows a well working solution?
*/

//                                                          | list of types of objects  |                        | list of objects |
#define PRESERVING( N, in_local_preserveObject,...) preserve< decltypes##N (__VA_ARGS__)> in_local_preserveObject(  __VA_ARGS__    )

#endif
}
{
//:info
/// Variadic template info() debugging helper
inline void info()
{
    std::cout<< std::endl;
}
/// Variadic template info() debugging helper
template<typename Last_T>
void info(const Last_T& _last)
{
    std::cout<< _last;
    info();
}
/// Variadic template info() debugging helper
template<typename First_T, typename... Remaining_T>
void info(const First_T& _first, const Remaining_T&... _remaining)
{
    std::cout<< _first<<' ';
    info( _remaining...);
}

// enable/disable debug helper info()
#if 1
//:INFO
/**
 @brief enabled: Lets you quicky and systematically print variables. Better for debugging then standard printing.
 @param ... expects any amount of objects that can be streamed to std::ostream.
 @sa VARVAL() PTRVAL() VARVALHEX() VARCHRNUM() VARCHRHEXNUM()

 \code INFO( a, b, c) \endcode
 does the same as
 \code std::cout << a << ' ' << b << ' ' << c << ' ' << std::endl \endcode
 but with less typing. It is intended to be used with macro's VARVAL,PTRVAL...VARCHRHEXNUM as a low level and low entry
 debugging aid. Those macro's make labels from the given variable and display the value (as of cout<< object standard
 or self defined operator << ) in single quotes.

 @b examples
 \code
 float my_value = 26.0; int div_num=5;

 // simple INFO example
 // -------------------
 INFO("my value text is",my_value","devided by",divnum,"is",my_value/div_num);

 // output "my value text is 26.000000 divided by 5 is 5.200000\n";

 // INFO with VARVAL example
 // ------------------------
 INFO(VARVAL(my_value),"divided by",VARVAL(div_num),"is",VARVAL(my_value/div_num));
 // produces
 std::cout<<"my_value"<<"="<<' '<<''''<<my_value<<''''<<' '
          <<"divided by"<<' '<<"div_num<<"="<<' '<<''''<<div_num<<''''<<' '
          <<"is"<<' '
          <<"my_value/div_num"<<' '<<''''<<my_value/div_num<<''''<<' '
          <<std::endl;

 // output: "my_value= '26.000000' divided by div_num= '5' is my_value/div_num= '5.200000' \n"


 \endcode

 @remarks INFO delibberately is designed to avoid custom formatting to keep it as simple as possible.
          If really needed you can still do custom formatting for a certain type of object by defining a operator<< .
          Or sometimes fall back to ordinary printing. Developers are in a hurry when debugging, they hate typing more
          then stricktly required.


*/
# define INFO(...) util::info(__VA_ARGS__)
#else
/// disabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define INFO(...)
#endif


//:DBG_INFO
#if DEBUG
/// DEBUG depended (enabled) better then printf easy to use (with format specifier) printing for the sole purpose of debugging
/// @sa INFO
# define DBG_INFO(...) INFO(__VA_ARGS__)
#else
/// DEBUG depended (enabled) better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define DBG_INFO(...)
#endif

#if ALLOC_DEBUG
/// ALLOC_DEBUG dependend (enabled) better then printf easy to use (with format specifier) printing for the sole purpose of debugging
/// @sa INFO
# define ALDBG_INFO(...) INFO(__VA_ARGS__)
#else
/// ALLOC_DEBUG dependend (enabled) better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define ALDBG_INFO(...)
#endif


//:cerror
/** cerror works like info but sends the output to std::cerr
 'cerror' i.s.o. error because that is to common and could class
 */
/// Variadic template cerror() debugging helper
inline void cerror()
{
    std::cerr<< std::endl;
}
/// Variadic template cerror() debugging helper
template<typename Last_T>
void cerror(const Last_T& _last)
{
    std::cerr<< _last;
    cerror();
}
/// Variadic template cerror() debugging helper
template<typename First_T, typename... Remaining_T>
void cerror(const First_T& _first, const Remaining_T&... _remaining)
{
    std::cerr<< _first<<' ';
    cerror( _remaining...);
}


//:CERROR
// enable/disable debug helper info()
#if 1
/// enabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define CERROR(...) util::cerror(__VA_ARGS__)
#else
/// disabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define CERROR(...)
#endif

#if DEBUG
/// DEBUG enabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define DBG_CERROR(...) CERROR(__VA_ARGS__)
#else
/// DEBUG disabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define DBG_CERROR(...)
#endif

#if ALLOC_DEBUG
/// ALLOC_DEBUG enabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define ALDBG_CERROR(...) CERROR(__VA_ARGS__)
#else
/// ALLOC_DEBUG disabled: better then printf easy to use (with format specifier) printing for the sole purpose of debugging
# define ALDBG_CERROR(...)
#endif


//:single_quote
/**
 @brief string representation of _value within single quotes and if hex is @b true
        the value is presented hexadecimally

 Used in 'See also' macro's

 @param[in] _value the value to be represented
 @param[in] hex is @b true the value is presented hexadecimally
 @sa info INFO VARVAL PTRVAL VARVALHEX VARCHRNUM VARCHRHEXNUM

 The mentioned macro's are all used to print variables systematically with the variable name as label and the value
 within single quotes.

 @b example
 \code
 int kaku=40;
 string naid="name identifier";

 INFO(VARVAL(kaku),VARVAL(naid));

 // prints  kaku:'40'  naid:'name identifier'
 \endcode

 INFO can take any amount of comma separated objects to print as long the type of the object is streamable to
 std::ostream

 @return single quoted (hexadecimal) string representation of _value
*/
template<typename Value_T>
std::string single_quote(const Value_T& _value, bool hex=false)
{
#if 0
    static /*unfortunally static, due to MSVC*/ std::stringstream ss;
    ss.seekp(0);
    ss.seekg(0);
#else
    std::stringstream ss;
#endif
    //std::stringstream sl;
    if ( hex ) ss<< std::hex;
    ss<<'\''<<_value<<'\'';
    if ( hex ) ss<< std::dec;
    return std::move( ss.str());
// Note: Which is correct? MSVC (appearently) passes the allocated buffer of the local stringstream,
//       it is as if we (incorrectly) would pass the address of a local char buffer (and that is only
//       valid if that buffer is static and not on the stack).
//       But string should be treated a value object (likewise int, float,... and a copy operator makes
//       a true copy of the chars in the buffer of the string object) and should be
//       copied (or moved) as a hole object. So G++ (and CLANG++) got it right.
//       This time ;-)
}


//:VARVAL
/// gives expression list of 2 strings, the first is the variable name the second its natuarally streamed value
#define VARVAL(_v) #_v,":",util::single_quote(_v)


//:PTRVAL
/// gives expression list of 2 strings, the first is the pointer name the second its std::ostream pointer representation
#define PTRVAL(_p) #_p,":",util::single_quote(reinterpret_cast<const void*>(_p)),"->",util::single_quote(*_p)


//:VARVALHEX
/// as VARVAL but the value (if nummeric) is presented hexadecimally
#define VARVALHEX(_v) #_v,":",util::single_quote(_v,/*hex=*/true)


//:VARCHRNUM
/** @brief byte specific VARVAL, represent byte as number not as character

 (u)int8_t types tend to be printed as a character by the default type overloading.
 By casting it to unsigned we select the number printing overload of ostream
 */
#define VARCHRNUM(_v)#_v,":",util::single_quote(CHAR2UINT_CAST(_v))


//:VARCHRHEXNUM
/// Like VARCHRNUM but the byte is hexadecimally formatted
#define VARCHRHEXNUM(_v)#_v,":",util::single_quote(CHAR2UINT_CAST(_v),/*hex=*/true)
}
    void maybe_run_onBeforeRestore()
    {
        if ( !m_should_call_onBeforeRestore ) {
             return;
        }
        m_onBeforeRestore(this);
    }
//:BYTE_MASK
/// mask 8 bits
#define BYTE_MASK  0xFF


//:NIBLE_MASK
/// mask lower 4 bits
#define NIBLE_MASK 0x0F


//:BIT_IN_BYTE_MASK
/// mask lowest 3 bits
#define BIT_IN_BYTE_MASK 0x07


//:PAIR_MASK
/// mask lower 2 bits
#define PAIR_MASK  0x03


//:BIT_MASK
/// mask lowest single bit
#define BIT_MASK   0x01


//:HIGH_BYTES_MASK
/// mask all except lower 8 bits
#define  HIGH_BYTES_MASK  (~BYTE_MASK)


//:HIGH_NIBLE_MASK
/// mask all except lower 4 bits
#define  HIGH_NIBLE_MASK (~NIBLE_MASK)


//:BITS_OUTSIDE_BYTE_MASK
///mask all except lower 3 bits
#define BITS_OUTSIDE_BYTE_MASK (~BIT_IN_BYTE_MASK)


//:HIGH_PAIRS_MASK
/// mask all except lower 2 bits
#define  HIGH_PAIRS_MASK (~PAIR_MASK)


//:HIGH_BITS_MASK
/// mask all except lower 1 bit
#define   HIGH_BITS_MASK   (~BIT_MASK)

#if 0 // depricated but still in use, turned of for detection where used.
//______________________________________________________________________________________________________________________
//
// property setter and getters
// ---------------------------
// Asume standard property
// method names   void    classname::set_property('const' type '&/&&' _property)  and
//             '?'type'?' classname::get_property() const
// The in 'quotes' parts indicate that the macro's do not require a certain
// precise type declaration.
//
// _SET has prefix underscore to indicate that it is input to the object
// GET_ has postfix underscore to indicate output from the object
//
// The unique form of these macro's with _ and _FROM_ should reduce the chance of name clashses with other frameworks
// (macro's 'SET' and 'GET' would be too general). Besides the underscores and _FROM_ make the source more readable
// However there is no limitation for which classes


//:_SET
/// object._SET(property)_FROM_(value);
#define _SET(property) set_##property(


//:_FROM
/// object._SET(property)_FROM_(value);
#define _FROM_(...) __VA_ARGS__)


//:_PROPERTY_SET
/// ismpl work arround  for _SET(property)_FROM_(...)
#define _PROPERTY_SET(property,...) set_##property(__VA_ARGS__)


//:GET_
/// object.GET_(value)
#define GET_(property) get_##property()
//
// end property setter and getters
//______________________________________________________________________________________________________________________
